// SPDX-License-Identifier: MIT
// SpatialDDS Discovery 1.0
// Lightweight announces for services, coverage, and content

module spatial {
  module disco {

    // -----------------------------
    // Asset references (middle-ground model)
    // -----------------------------
    //
    // Base contract: uniform access + integrity for all assets.
    // Optional, namespaced metadata bags carry type-specific details
    // without inflating the base schema.
    //
    // Example: media_type could be
    //   "application/vnd.sdds.features+json;algo=orb;v=1"
    //
    // Namespaced metadata uses JSON strings so producers can include
    // structured details without schema churn.
    //
    @appendable struct AssetMetaKV {
      string namespace;  // e.g., "sensing.vision.features"
      string json;       // JSON object string; producer-defined for this namespace
    };

    @appendable struct AssetRef {
      string uri;          // required: how to fetch
      string media_type;   // required: IANA or registry-friendly type (with params)
      string hash;         // required: e.g., "sha256:<hex>"
      uint64 bytes;        // required: size in bytes
      sequence<AssetMetaKV, 32> meta;  // optional: zero or more namespaced bags
    };

    const string MODULE_ID = "spatial.discovery/1.0";

    typedef spatial::core::Time Time;
    typedef spatial::core::Aabb3 Aabb3;
    // Canonical manifest references use the spatialdds:// URI scheme.
    typedef string SpatialUri;

    // --- Profile version advertisement (additive) ---
    // Semver per profile: name@MAJOR.MINOR
    // Each row declares a contiguous range of MINORs within a single MAJOR.
    @appendable struct ProfileSupport {
      string name;        // e.g., "core", "discovery", "sensing.common", "sensing.rad"
      uint32 major;       // compatible major (e.g., 1)
      uint32 min_minor;   // lowest supported minor within 'major' (e.g., 0)
      uint32 max_minor;   // highest supported minor within 'major' (e.g., 2)  // supports 1.0..1.2
      boolean preferred;  // optional tie-breaker hint (usually false)
    };

    // --- Optional feature flags (namespaced strings, e.g., "blob.crc32", "rad.tensor.zstd") ---
    @appendable struct FeatureFlag {
      string name;
    };

    // --- Capabilities advertised in-band on the discovery bus ---
    @appendable struct Capabilities {
      sequence<ProfileSupport, 64> supported_profiles;
      sequence<string, 32>         preferred_profiles; // e.g., ["discovery@1.2","core@1.*"]
      sequence<FeatureFlag, 64>    features;           // optional feature flags
    };

    // --- Topic metadata to enable selection without parsing payloads ---
    @appendable struct TopicMeta {
      string name;        // e.g., "spatialdds/perception/cam_front/video_frame/v1"
      string type;        // registered type (see Topic Identity & QoS ยง4.6)
      string version;     // e.g., "v1"
      string qos_profile; // e.g., "VIDEO_LIVE"
      // optional advisory hints (topic-level, not per-message)
      float32 target_rate_hz;
      uint32  max_chunk_bytes;
    };

    enum ServiceKind {
      VPS = 0,
      MAPPING = 1,
      RELOCAL = 2,
      SEMANTICS = 3,
      STORAGE = 4,
      CONTENT = 5,
      ANCHOR_REGISTRY = 6,
      OTHER = 255
    };

    @appendable struct KV {
      string key;
      string value;
    };

    // CoverageElement: if frame == "earth-fixed", bbox is [west,south,east,north] in degrees (EPSG:4326/4979);
    // otherwise local meters; volume is AABB in meters.
    @appendable struct CoverageElement {
      string type;              // "bbox" | "volume"
      string frame;             // coordinate frame for this element (e.g., "earth-fixed", "map")
      string crs;               // optional CRS identifier for earth-fixed frames (e.g., EPSG code)
      double bbox[4];           // [west, south, east, north] when type == "bbox"
      Aabb3 aabb;               // axis-aligned bounds when type == "volume"
      // Explicit global coverage toggle: when true, bbox and aabb may be ignored by consumers.
      boolean global;
    };

    // Quaternion follows GeoPose: unit [x,y,z,w]; pose maps FROM 'from' TO 'to'
    @appendable struct Transform {
      string from;              // source frame (e.g., "map")
      string to;                // target frame (e.g., "earth-fixed")
      string stamp;             // ISO-8601 timestamp for this transform
      uint32 valid_for_s;       // validity horizon in seconds
      // New: explicit origin for validity window. Consumers evaluate expiry at
      // (valid_from + valid_for_s). If absent, treat valid_from == stamp.
      Time   valid_from;
      double t_m[3];            // meters in 'from' frame
      double q_xyzw[4];         // GeoPose order [x,y,z,w]
    };

    @appendable struct ServiceAnnounce {
      @key string service_id;
      string name;
      ServiceKind kind;
      string version;
      string org;
      sequence<string,16> rx_topics;
      sequence<string,16> tx_topics;
      sequence<KV,32> hints;
      // New: wire-level capability advertisement for version negotiation.
      Capabilities caps;                 // in-band capabilities (profiles + features)
      sequence<TopicMeta,128> topics;    // topic list with typed-topic metadata
      sequence<CoverageElement,16> coverage;
      string coverage_canonical_frame;  // canonical frame consumers should use when evaluating coverage
      Time coverage_eval_time;          // optional evaluation time for transforming coverage elements
      sequence<Transform,8> transforms;
      SpatialUri manifest_uri;  // MUST be a spatialdds:// URI for this service manifest
      string auth_hint;
      Time stamp;
      uint32 ttl_sec;
    };

    @appendable struct CoverageHint {
      @key string service_id;
      sequence<CoverageElement,16> coverage;
      string coverage_canonical_frame;
      Time coverage_eval_time;
      sequence<Transform,8> transforms;
      Time stamp;
      uint32 ttl_sec;
    };

    @appendable struct CoverageQuery {
      // Correlates responses to a specific query instance.
      @key uint64 query_id;
      sequence<CoverageElement,4> coverage;  // requested regions of interest
      string coverage_canonical_frame;
      Time coverage_eval_time;
      // Responders publish CoverageResponse samples to this topic.
      string reply_topic;
      Time stamp;
      uint32 ttl_sec;
    };

    @appendable struct CoverageResponse {
      // Mirrors CoverageQuery.query_id for correlation.
      uint64 query_id;
      // Result page.
      sequence<ContentAnnounce,65535> results;
      // Empty when no further pages remain.
      string next_page_token;
    };

    @appendable struct ContentAnnounce {
      @key string content_id;
      string provider_id;
      string title;
      string summary;
      sequence<string,16> tags;
      string class_id;
      SpatialUri manifest_uri;  // MUST be a spatialdds:// URI for this content manifest
      sequence<CoverageElement,16> coverage;
      string coverage_canonical_frame;
      Time coverage_eval_time;
      sequence<Transform,8> transforms;
      Time available_from;
      Time available_until;
      Time stamp;
      uint32 ttl_sec;
    };

  }; // module disco
};
