// SPDX-License-Identifier: MIT
// SpatialDDS Discovery 1.0
// Lightweight announces for services, coverage, and content

module spatial {
  module disco {

    const string MODULE_ID = "spatial.discovery/1.0";

    typedef spatial::core::Time Time;
    typedef spatial::core::Aabb3 Aabb3;
    // Canonical manifest references use the spatialdds:// URI scheme.
    typedef string SpatialUri;

    enum ServiceKind {
      VPS = 0,
      MAPPING = 1,
      RELOCAL = 2,
      SEMANTICS = 3,
      STORAGE = 4,
      CONTENT = 5,
      ANCHOR_REGISTRY = 6,
      OTHER = 255
    };

    @appendable struct KV {
      string key;
      string value;
    };

    // CoverageElement: if frame == "earth-fixed", bbox is [west,south,east,north] in degrees (EPSG:4326/4979);
    // otherwise local meters; volume is AABB in meters.
    @appendable struct CoverageElement {
      string type;              // "bbox" | "volume"
      string frame;             // coordinate frame for this element (e.g., "earth-fixed", "map")
      string crs;               // optional CRS identifier for earth-fixed frames (e.g., EPSG code)
      double bbox[4];           // [west, south, east, north] when type == "bbox"
      Aabb3 aabb;               // axis-aligned bounds when type == "volume"
      // Explicit global coverage toggle: when true, bbox and aabb may be ignored by consumers.
      boolean global;
    };

    // Quaternion follows GeoPose: unit [x,y,z,w]; pose maps FROM 'from' TO 'to'
    @appendable struct Transform {
      string from;              // source frame (e.g., "map")
      string to;                // target frame (e.g., "earth-fixed")
      string stamp;             // ISO-8601 timestamp for this transform
      uint32 valid_for_s;       // validity horizon in seconds
      // New: explicit origin for validity window. Consumers evaluate expiry at
      // (valid_from + valid_for_s). If absent, treat valid_from == stamp.
      Time   valid_from;
      double t_m[3];            // meters in 'from' frame
      double q_xyzw[4];         // GeoPose order [x,y,z,w]
    };

    @appendable struct ServiceAnnounce {
      @key string service_id;
      string name;
      ServiceKind kind;
      string version;
      string org;
      sequence<string,16> rx_topics;
      sequence<string,16> tx_topics;
      sequence<KV,32> hints;
      sequence<CoverageElement,16> coverage;
      string coverage_canonical_frame;  // canonical frame consumers should use when evaluating coverage
      Time coverage_eval_time;          // optional evaluation time for transforming coverage elements
      sequence<Transform,8> transforms;
      SpatialUri manifest_uri;  // MUST be a spatialdds:// URI for this service manifest
      string auth_hint;
      Time stamp;
      uint32 ttl_sec;
    };

    @appendable struct CoverageHint {
      @key string service_id;
      sequence<CoverageElement,16> coverage;
      string coverage_canonical_frame;
      Time coverage_eval_time;
      sequence<Transform,8> transforms;
      Time stamp;
      uint32 ttl_sec;
    };

    @appendable struct CoverageQuery {
      @key string query_id;
      sequence<CoverageElement,4> coverage;  // requested regions of interest
      string coverage_canonical_frame;
      Time coverage_eval_time;
      Time stamp;
      uint32 ttl_sec;
    };

    @appendable struct ContentAnnounce {
      @key string content_id;
      string provider_id;
      string title;
      string summary;
      sequence<string,16> tags;
      string class_id;
      SpatialUri manifest_uri;  // MUST be a spatialdds:// URI for this content manifest
      sequence<CoverageElement,16> coverage;
      string coverage_canonical_frame;
      Time coverage_eval_time;
      sequence<Transform,8> transforms;
      Time available_from;
      Time available_until;
      Time stamp;
      uint32 ttl_sec;
    };

  }; // module disco
};
