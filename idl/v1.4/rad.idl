// SPDX-License-Identifier: MIT
// SpatialDDS Radar (RAD) 1.0 — Extension profile

module spatial { module sensing { module rad {

  // Reuse Core + Sensing Common types
  typedef spatial::core::Time                      Time;
  typedef spatial::core::PoseSE3                   PoseSE3;
  typedef spatial::core::BlobRef                   BlobRef;

  typedef spatial::sensing::common::Axis           Axis;
  typedef spatial::sensing::common::ROI            ROI;
  typedef spatial::sensing::common::Codec          Codec;
  typedef spatial::sensing::common::PayloadKind    PayloadKind;
  typedef spatial::sensing::common::SampleType     SampleType;
  typedef spatial::sensing::common::StreamMeta     StreamMeta;
  typedef spatial::sensing::common::FrameHeader    FrameHeader;
  typedef spatial::sensing::common::FrameQuality   FrameQuality;
  typedef spatial::sensing::common::ROIRequest     ROIRequest;
  typedef spatial::sensing::common::ROIReply       ROIReply;

  // Layout of the RAD tensor
  enum RadTensorLayout { RA_D = 0, R_AZ_EL_D = 1, CUSTOM = 255 };

  // Static description (publish infrequently; RELIABLE + TRANSIENT_LOCAL)
  @appendable struct RadMeta {
    @key string stream_id;                 // stable id for this radar stream
    StreamMeta base;                       // frame_id, T_bus_sensor, nominal_rate_hz, schema_version
    RadTensorLayout layout;                // order of axes
    sequence<Axis, 8> axes;                // axis definitions (range/az/el/doppler)
    SampleType voxel_type;                 // pre-compression sample type (e.g., CF16, U8_MAG)
    string physical_meaning;               // e.g., "post 3D-FFT complex baseband"

    // Default payload settings for frames
    PayloadKind payload_kind;              // DENSE_TILES, SPARSE_COO, or LATENT
    Codec       codec;                     // LZ4, ZSTD, FP8Q, AE_V1, ...
    float       quant_scale;               // valid if has_quant_scale
    boolean     has_quant_scale;
    uint32      tile_size[4];              // for DENSE_TILES; unused dims = 1
  };

  // Per-frame index (small, frequent; BEST_EFFORT, KEEP_LAST=1)
  // Heavy bytes ride as blobs referenced here (tensor tiles, sparse blocks, or latent)
  @appendable struct RadFrame {
    @key string stream_id;
    uint64 frame_seq;

    FrameHeader hdr;                       // t_start/t_end, optional sensor_pose, blobs[]
    PayloadKind payload_kind;              // may override defaults
    Codec       codec;                     // may override defaults
    SampleType  voxel_type_after_decode;   // post-decode type (e.g., CF16 → MAG_F16)
    float       quant_scale;               // valid if has_quant_scale
    boolean     has_quant_scale;

    FrameQuality quality;                  // SNR/valid%/health note
    string proc_chain;                     // e.g., "FFT3D->hann->OS-CFAR"
  };

  // Lightweight derivative for fast fusion/tracking (optional)
  @appendable struct RadDetection {
    double xyz_m[3];       // Cartesian point in base.frame_id
    double v_r_mps;        // radial velocity (optional; NaN if unknown)
    float  intensity;      // reflectivity/magnitude
    float  quality;        // 0..1
  };

  @appendable struct RadDetectionSet {
    @key string stream_id;
    uint64 frame_seq;
    string frame_id;       // coordinate frame of xyz_m
    sequence<RadDetection, 32768> dets;
    Time   stamp;
  };

}; }; };
