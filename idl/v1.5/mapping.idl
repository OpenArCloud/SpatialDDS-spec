// SPDX-License-Identifier: MIT
// SpatialDDS Mapping Extension 1.5
//
// Map lifecycle metadata, multi-source edge types, and inter-map
// alignment primitives for multi-agent collaborative mapping.

#ifndef SPATIAL_CORE_INCLUDED
#define SPATIAL_CORE_INCLUDED
#include "core.idl"
#endif

module spatial {
  module mapping {

    const string MODULE_ID = "spatial.mapping/1.5";

    typedef builtin::Time Time;
    typedef spatial::core::PoseSE3    PoseSE3;
    typedef spatial::core::FrameRef   FrameRef;
    typedef spatial::core::CovMatrix  CovMatrix;
    typedef spatial::core::BlobRef    BlobRef;
    typedef spatial::common::MetaKV   MetaKV;
    typedef spatial::core::GeoPose   GeoPose;


    // ================================================================
    // 1. MAP METADATA
    // ================================================================

    // Representation kind — what type of spatial map this describes.
    // The enum identifies the high-level representation; the actual
    // encoding and codec live in TileMeta.encoding as today.
    enum MapKind {
      @value(0) POSE_GRAPH,       // sparse keyframe graph (Node + Edge)
      @value(1) OCCUPANCY_GRID,   // 2D or 2.5D grid (nav planning)
      @value(2) POINT_CLOUD,      // dense 3D point cloud
      @value(3) MESH,             // triangle mesh / surface
      @value(4) TSDF,             // truncated signed distance field
      @value(5) VOXEL,            // volumetric voxel grid
      @value(6) NEURAL_FIELD,     // NeRF, 3DGS, neural SDF (see neural profile)
      @value(7) FEATURE_MAP,      // visual place recognition / bag-of-words
      @value(8) SEMANTIC_MAP,     // semantic / panoptic map layer
      @value(9) MAP_OTHER
    };

    // Map status — lifecycle state.
    enum MapStatus {
      @value(0) BUILDING,         // actively being constructed (SLAM running)
      @value(1) OPTIMIZING,       // global optimization / bundle adjustment in progress
      @value(2) STABLE,           // optimized and not actively changing
      @value(3) FROZEN,           // immutable reference map (no further updates)
      @value(4) STATUS_DEPRECATED // superseded by a newer map; consumers should migrate
    };

    // Quality metrics — optional per-map health indicators.
    // All fields are optional via has_* flags to avoid mandating
    // metrics that not every SLAM system produces.
    @extensibility(APPENDABLE) struct MapQuality {
      boolean has_loop_closure_count;
      uint32  loop_closure_count;       // total loop closures accepted

      boolean has_mean_residual;
      double  mean_residual;            // mean constraint residual after optimization (meters)

      boolean has_max_drift_m;
      double  max_drift_m;              // estimated worst-case drift (meters)

      boolean has_coverage_pct;
      float   coverage_pct;             // fraction of declared extent actually mapped [0..1]

      boolean has_keyframe_count;
      uint32  keyframe_count;           // number of keyframes / nodes

      boolean has_landmark_count;
      uint32  landmark_count;           // number of 3D landmarks
    };

    // Top-level map descriptor. Published with RELIABLE + TRANSIENT_LOCAL
    // so late joiners discover all active maps immediately.
    //
    // One MapMeta per (map_id, source_id) — a single physical map may have
    // multiple representations (e.g., pose graph + occupancy grid + mesh),
    // each published as a separate MapMeta with the same map_id but
    // different kind and source_id.
    @extensibility(APPENDABLE) struct MapMeta {
      @key string map_id;               // unique map identifier
      @key string source_id;            // producing agent / SLAM system

      MapKind   kind;                   // representation type
      MapStatus status;                 // lifecycle state
      string    algorithm;              // e.g., "ORB-SLAM3", "Cartographer", "RTAB-Map", "LIO-SAM"
      FrameRef  frame_ref;              // map's canonical coordinate frame

      // Spatial extent (axis-aligned in frame_ref)
      boolean has_extent;
      spatial::core::Aabb3 extent;      // bounding box of mapped region

      // Geo-anchor: where this map sits on Earth (when known)
      boolean has_geopose;
      GeoPose geopose;                  // map origin in WGS84

      // Versioning — aligns with core Node/Edge graph_epoch
      uint64  graph_epoch;              // increments on major rebases / merges
      uint64  revision;                 // monotonic within an epoch (fine-grained updates)

      // Quality
      boolean has_quality;
      MapQuality quality;

      // Timing
      Time    created;                  // map creation time
      Time    stamp;                    // last update time

      // Content references — how to get the map data
      // For pose graphs: subscribe to Node/Edge on the standard topic with this map_id
      // For dense maps: these blob_ids reference the backing TileMeta/BlobChunk data
      sequence<BlobRef, 32> blob_refs;  // optional: pre-built map artifacts

      // Extensible metadata (encoding details, sensor suite, etc.)
      sequence<MetaKV, 32> attributes;

      string schema_version;            // MUST be "spatial.mapping/1.5"
    };


    // ================================================================
    // 2. EXTENDED EDGE TYPES
    // ================================================================

    // Extends core::EdgeTypeCore (ODOM=0, LOOP=1) with constraint types
    // needed for multi-agent, multi-sensor pose graph optimization.
    //
    // Values 0-1 are identical to EdgeTypeCore. Core consumers that
    // only understand ODOM/LOOP can safely downcast by treating
    // unknown values as LOOP.
    enum EdgeType {
      @value(0)  ODOM,            // odometry (sequential)
      @value(1)  LOOP,            // intra-map loop closure
      @value(2)  INTER_MAP,       // cross-map loop closure (between two agents' maps)
      @value(3)  GPS,             // absolute pose from GNSS
      @value(4)  ANCHOR,          // constraint from recognizing a shared anchor
      @value(5)  IMU_PREINT,      // IMU pre-integration factor
      @value(6)  GRAVITY,         // gravity direction prior
      @value(7)  PLANE,           // planar constraint (e.g., ground plane)
      @value(8)  SEMANTIC_EDGE,   // semantic co-observation ("both see the same door")
      @value(9)  EDGE_MANUAL,     // human-provided alignment
      @value(10) RANGE,           // range-only distance constraint (UWB, acoustic, BLE)
      @value(11) EDGE_OTHER
    };

    // Extended edge that carries the richer EdgeType plus provenance.
    // Supplements core::Edge — publishers that produce multi-source
    // constraints publish mapping::Edge; the fields are a superset
    // of core::Edge.
    @extensibility(APPENDABLE) struct Edge {
      string map_id;
      @key string edge_id;
      string from_id;                   // source node (may be in a different map_id)
      string to_id;                     // target node
      EdgeType type;                    // extended type enum
      PoseSE3 T_from_to;               // relative pose: from_id → to_id
      spatial::common::Mat6x6 information; // 6x6 info matrix (row-major)
      Time   stamp;
      string source_id;                 // who produced this constraint
      uint64 seq;
      uint64 graph_epoch;

      // Cross-map provenance (populated when type == INTER_MAP)
      boolean has_from_map_id;
      string  from_map_id;              // map_id of from_id's origin
      boolean has_to_map_id;
      string  to_map_id;                // map_id of to_id's origin

      // Match quality for loop closures and cross-map edges
      boolean has_match_score;
      float   match_score;              // similarity / inlier ratio [0..1]
      boolean has_inlier_count;
      uint32  inlier_count;             // feature inliers supporting this edge

      // Range-only constraint (populated when type == RANGE)
      // For range-only edges, T_from_to and information are unused (set to
      // identity/zero); the scalar range_m is the primary payload.
      // The optimizer treats this as a distance-only factor between from_id
      // and to_id: ||pos(from_id) - pos(to_id)|| = range_m ± range_std_m.
      boolean has_range_m;
      float   range_m;                  // measured distance (meters)
      boolean has_range_std_m;
      float   range_std_m;              // 1-sigma distance uncertainty (meters)
    };


    // ================================================================
    // 3. MAP ALIGNMENT
    // ================================================================

    // How an alignment was established.
    enum AlignmentMethod {
      @value(0) VISUAL_LOOP,      // feature-based visual closure
      @value(1) LIDAR_ICP,        // point cloud registration (ICP / NDT)
      @value(2) ANCHOR_MATCH,     // shared anchor recognition
      @value(3) GPS_COARSE,       // GPS-derived coarse alignment
      @value(4) SEMANTIC_MATCH,   // semantic landmark co-observation
      @value(5) ALIGN_MANUAL,     // operator-provided ground truth
      @value(6) MULTI_METHOD,     // combination of methods
      @value(7) RANGE_COARSE,     // range-only (UWB, acoustic) coarse alignment
      @value(8) ALIGN_OTHER
    };

    // Inter-map transform: aligns map_id_from's frame to map_id_to's frame,
    // with provenance and quality metadata.
    //
    // This is the merge primitive. When a multi-robot SLAM system determines
    // that two maps overlap, it publishes a MapAlignment. Downstream consumers
    // (planning, visualization, fleet coordination) use this to reason across
    // maps without waiting for a full graph merge.
    @extensibility(APPENDABLE) struct MapAlignment {
      @key string alignment_id;         // unique alignment identifier

      string map_id_from;               // source map
      string map_id_to;                 // target map (reference)
      PoseSE3 T_from_to;               // transform: map_id_from frame → map_id_to frame
      CovMatrix cov;                    // uncertainty of the alignment

      AlignmentMethod method;           // how the alignment was computed
      Time   stamp;                     // when the alignment was computed
      string source_id;                 // who computed it

      // Quality evidence
      boolean has_match_score;
      float   match_score;              // overall alignment quality [0..1]
      boolean has_overlap_pct;
      float   overlap_pct;              // estimated spatial overlap [0..1]
      boolean has_supporting_edges;
      uint32  supporting_edges;         // number of cross-map edges backing this alignment

      // Versioning — alignment may be refined as more evidence accumulates
      uint64  revision;                 // monotonic; newer revision supersedes older

      // Optional: list of cross-map edge_ids that support this alignment
      sequence<string, 64> evidence_edge_ids;

      string schema_version;            // MUST be "spatial.mapping/1.5"
    };


    // ================================================================
    // 4. MAP LIFECYCLE EVENTS
    // ================================================================

    // Lightweight event published when a map undergoes a significant
    // lifecycle transition. Subscribers (fleet managers, UI dashboards,
    // data pipelines) can react without polling MapMeta.
    enum MapEventKind {
      @value(0) CREATED,          // new map started
      @value(1) EPOCH_ADVANCE,    // graph_epoch incremented (rebase / merge)
      @value(2) STATUS_CHANGE,    // status field changed (e.g., BUILDING → STABLE)
      @value(3) ALIGNMENT_NEW,    // new MapAlignment published involving this map
      @value(4) ALIGNMENT_UPDATE, // existing MapAlignment revised
      @value(5) EVENT_DEPRECATED, // map marked deprecated
      @value(6) DELETED           // map data removed from bus
    };

    @extensibility(APPENDABLE) struct MapEvent {
      @key string map_id;
      MapEventKind event;
      string source_id;
      Time   stamp;

      // Context (populated per event kind)
      boolean has_new_status;
      MapStatus new_status;             // for STATUS_CHANGE

      boolean has_new_epoch;
      uint64  new_epoch;                // for EPOCH_ADVANCE

      boolean has_alignment_id;
      string  alignment_id;             // for ALIGNMENT_NEW / ALIGNMENT_UPDATE

      // Human-readable reason
      boolean has_reason;
      string  reason;                   // e.g., "merged with map/robot-B after 42 loop closures"
    };

  }; // module mapping
};   // module spatial
